package logging

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	logging "gbenson.net/hive/logging/event"
	"gbenson.net/hive/logging/internal/modifiers"
	"gbenson.net/hive/logging/sources/systemd"
)

// SpoolerEndpoint is a hive-log-spooler API endpoint.
type SpoolerEndpoint struct {
	URL       string `json:"url"`
	BasicAuth creds  `json:"http_auth,omitempty"`
	Username  string `json:"username"`
	Password  string `json:"password"`
}

// creds holds credentials for authenticating with a
// hive-log-spooler endpoint.
type creds struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Spooler is a connection to a hive-log-spooler API endpoint.
type Spooler struct {
	resp    *http.Response
	scanner *bufio.Scanner
	event   logging.Event
	err     error
}

// NewSpooler returns a new log spooler.
func NewSpooler(ctx context.Context, ep *SpoolerEndpoint) *Spooler {
	s := &Spooler{}
	s.resp, s.err = postRequest(ctx, ep)
	if s.err == nil {
		s.scanner = bufio.NewScanner(s.resp.Body)
	}
	return s
}

func postRequest(ctx context.Context, ep *SpoolerEndpoint) (*http.Response, error) {
	data := make(url.Values)
	data.Set("u", ep.Username)
	data.Set("p", ep.Password)
	body := strings.NewReader(data.Encode())

	req, err := http.NewRequestWithContext(ctx, "POST", ep.URL, body)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.SetBasicAuth(ep.BasicAuth.Username, ep.BasicAuth.Password)

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	} else if resp.StatusCode != http.StatusOK {
		return resp, fmt.Errorf("http error: %s", resp.Status)
	} else if ct := resp.Header.Get("Content-Type"); ct != "application/jsonl" {
		return resp, fmt.Errorf("unexpected content-type %q", ct)
	}

	return resp, nil
}

// Close closes the underlying HTTP response.
func (s *Spooler) Close() error {
	if resp := s.resp; resp != nil {
		return resp.Body.Close()
	}
	return nil
}

// Err returns the first non-EOF error that was encountered by the Spooler.
func (s *Spooler) Err() error {
	err := s.err
	if err == nil {
		if err = s.scanner.Err(); err == nil {
			return nil
		}
		s.err = err
	}
	if err == io.EOF {
		return nil
	}
	return err
}

// Spool advances the Spooler to the next event, which will then be
// available through the Spooler.Event method. It returns false when
// there are no more events, either by reaching the end of the input
// or an error. After Spool returns false, the Spooler.Err method will
// return any error that occurred during spooling, except that if it
// was io.EOF, Spooler.Err will return nil.
func (s *Spooler) Spool() bool {
	if s.err != nil {
		return false
	}

	if !s.scanner.Scan() {
		if err := s.scanner.Err(); err != nil {
			s.err = err
		} else {
			s.err = io.EOF
		}
		return false
	}

	b := s.scanner.Bytes()

	var entry systemd.JournalEntry
	if err := json.Unmarshal(b, &entry); err != nil {
		s.err = err
		return false
	}

	s.event = modifiers.Apply(&entry)
	return true
}

// Event returns the most recent event generated by a call to Spooler.Spool.
func (s *Spooler) Event() logging.Event {
	return s.event
}
